<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `lambda_http` crate."><meta name="keywords" content="rust, rustlang, rust-lang, lambda_http"><title>lambda_http - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../lambda_http/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate lambda_http</p><div class='block version'><p>Version 0.2.0-beta.1</p></div><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all lambda_http's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'lambda_http', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/lambda_http/lib.rs.html#1-199' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>lambda_http</a></span></h1><div class='docblock'><p>Enriches the <code>lambda</code> crate with <a href="https://github.com/hyperium/http"><code>http</code></a>
types targeting AWS <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html">ALB</a>, <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html">API Gateway</a> REST and HTTP API lambda integrations.</p>
<p>This crate abstracts over all of these trigger events using standard <a href="https://github.com/hyperium/http"><code>http</code></a> types minimizing the mental overhead
of understanding the nuances and variation between trigger details allowing you to focus more on your application while also giving you to the maximum flexibility to
transparently use whichever lambda trigger suits your application and cost optimiztions best.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1><h2 id="hello-world" class="section-header"><a href="#hello-world">Hello World</a></h2>
<p><code>lambda_http</code> handlers adapt to the standard <code>lambda::Handler</code> interface using the <a href="fn.handler.html"><code>handler</code></a> function.</p>
<p>The simplest case of an http handler is a function of an <code>http::Request</code> to a type that can be lifted into an <code>http::Response</code>.
You can learn more about these types <a href="trait.IntoResponse.html">here</a>.</p>
<p>Adding an <code>#[lambda(http)]</code> attribute to a <code>#[tokio::run]</code>-decorated <code>main</code> function will setup and run the Lambda function.</p>
<p>Note: this comes at the expense of any onetime initialization your lambda task might find value in.
The full body of your <code>main</code> function will be executed on <strong>every</strong> invocation of your lambda task.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">lambda_http</span>::{<span class="ident">lambda</span>::{<span class="ident">lambda</span>, <span class="ident">Context</span>}, <span class="ident">Request</span>, <span class="ident">IntoResponse</span>};

<span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span>;

<span class="attribute">#[<span class="ident">lambda</span>(<span class="ident">http</span>)]</span>
<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>(<span class="kw">_</span>: <span class="ident">Request</span>, <span class="kw">_</span>: <span class="ident">Context</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw">impl</span> <span class="ident">IntoResponse</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="string">&quot;ðŸ‘‹ world!&quot;</span>)
}</pre></div>
<h2 id="hello-world-without-macros" class="section-header"><a href="#hello-world-without-macros">Hello World, Without Macros</a></h2>
<p>For cases where your lambda might benfit from one time function initializiation might
prefer a plain <code>main</code> function and invoke <code>lambda::run</code> explicitly in combination with the <a href="fn.handler.html"><code>handler</code></a> function.
Depending on the runtime cost of your dependency bootstrapping, this can reduce the overall latency of your functions execution path.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">lambda_http</span>::{<span class="ident">handler</span>, <span class="ident">lambda</span>};

<span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="comment">// initialize dependencies once here for the lifetime of your</span>
    <span class="comment">// lambda task</span>
    <span class="ident">lambda</span>::<span class="ident">run</span>(<span class="ident">handler</span>(<span class="op">|</span><span class="ident">request</span>, <span class="ident">context</span><span class="op">|</span> <span class="kw">async</span> { <span class="prelude-val">Ok</span>(<span class="string">&quot;ðŸ‘‹ world!&quot;</span>) })).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}
</pre></div>
<h2 id="leveraging-trigger-provided-data" class="section-header"><a href="#leveraging-trigger-provided-data">Leveraging trigger provided data</a></h2>
<p>You can also access information provided directly from the underlying trigger events, like query string parameters,
with the <a href="trait.RequestExt.html"><code>RequestExt</code></a> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">lambda_http</span>::{<span class="ident">handler</span>, <span class="ident">lambda</span>::{<span class="self">self</span>, <span class="ident">Context</span>}, <span class="ident">IntoResponse</span>, <span class="ident">Request</span>, <span class="ident">RequestExt</span>};

<span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="ident">lambda</span>::<span class="ident">run</span>(<span class="ident">handler</span>(<span class="ident">hello</span>)).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">hello</span>(
    <span class="ident">request</span>: <span class="ident">Request</span>,
    <span class="kw">_</span>: <span class="ident">Context</span>
) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw">impl</span> <span class="ident">IntoResponse</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="macro">format</span><span class="macro">!</span>(
        <span class="string">&quot;hello {}&quot;</span>,
        <span class="ident">request</span>
            .<span class="ident">query_string_parameters</span>()
            .<span class="ident">get</span>(<span class="string">&quot;name&quot;</span>)
            .<span class="ident">unwrap_or_else</span>(<span class="op">||</span> <span class="string">&quot;stranger&quot;</span>)
    ))
}</pre></div>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use <a class="mod" href="https://docs.rs/http/0.2.0/http/index.html" title="mod http">http</a>;</code></td></tr><tr><td><code>pub use <a class="mod" href="../lambda/index.html" title="mod lambda">lambda</a>;</code></td></tr><tr><td><code>pub use crate::ext::<a class="trait" href="../lambda_http/ext/trait.RequestExt.html" title="trait lambda_http::ext::RequestExt">RequestExt</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="ext/index.html" title='lambda_http::ext mod'>ext</a></td><td class='docblock-short'><p>Extension methods for <code>http::Request</code> types</p>
</td></tr><tr class='module-item'><td><a class="mod" href="request/index.html" title='lambda_http::request mod'>request</a></td><td class='docblock-short'><p>ALB and API Gateway request adaptations</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Adapter.html" title='lambda_http::Adapter struct'>Adapter</a></td><td class='docblock-short'><p>Exists only to satisfy the trait cover rule for <code>lambda::Handler</code> impl</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Context.html" title='lambda_http::Context struct'>Context</a></td><td class='docblock-short'><p>The Lambda function execution context. The values in this struct
are populated using the <a href="https://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html">Lambda environment variables</a>
and the headers returned by the poll request to the Runtime APIs.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Response.html" title='lambda_http::Response struct'>Response</a></td><td class='docblock-short'><p>Represents an HTTP response</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StrMap.html" title='lambda_http::StrMap struct'>StrMap</a></td><td class='docblock-short'><p>A read-only view into a map of string data which may contain multiple values</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Body.html" title='lambda_http::Body enum'>Body</a></td><td class='docblock-short'><p>Representation of http request and response bodies as supported
by API Gateway and ALBs.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Handler.html" title='lambda_http::Handler trait'>Handler</a></td><td class='docblock-short'><p>Functions serving as ALB and API Gateway REST and HTTP API handlers must conform to this type.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.IntoResponse.html" title='lambda_http::IntoResponse trait'>IntoResponse</a></td><td class='docblock-short'><p>A conversion of self into a <code>Response&lt;Body&gt;</code> for various types.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.handler.html" title='lambda_http::handler fn'>handler</a></td><td class='docblock-short'><p>Adapts a <a href="trait.Handler.html"><code>Handler</code></a> to the <code>lambda::run</code> interface</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.Request.html" title='lambda_http::Request type'>Request</a></td><td class='docblock-short'><p>Type alias for <code>http::Request</code>s with a fixed <a href="enum.Body.html"><code>Body</code></a> type</p>
</td></tr></table><h2 id='attributes' class='section-header'><a href="#attributes">Attribute Macros</a></h2>
<table><tr class='module-item'><td><a class="attr" href="attr.lambda.html" title='lambda_http::lambda attr'>lambda</a></td><td class='docblock-short'></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "lambda_http";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>